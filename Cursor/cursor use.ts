// ### cursor使用
// 让cursor他自己生成原型项目想法的提示词

// 提示词进行优化

// 先让cursor以html和css的方式给我出产品的静态页面原型图，再通过给原型图生成代码，效果远远好于让他自己直接生成代码

// 提示词难免太长——分步提示词指令集放入notpade做记录
// 为了避免内容过长导致生成内容中断，分步骤执行提示词
// @tips（存放了分布生成的指令集的文档），用agent模式去生成
// ![[Pasted image 20250317162252.png]]

// # 实用合作流程：简单可行的方案



// ## 简单三步工作流

// ### 步骤1：项目定义文档（一次性创建）
// 创建一个简短文档包含：
// ```
// 项目名称：[名称]
// 核心功能：[3-5个要点]
// 技术栈：[前端/后端技术]
// 目标用户：[简要描述]
// ```

// ### 步骤2：功能开发模板（每个功能使用）
// 对每个功能使用这个模板提问：
// ```
// 功能：[具体功能名称]
// 输入：[用户提供什么]
// 输出：[功能产生什么结果]
// 流程：[简要步骤]
// 请先提供UI原型，再生成代码实现
// ```

// ### 步骤3：反馈循环模板
// 当我提供实现后，用这个简单模板回应：
// ```
// 可行的部分：[列出正确的部分]
// 需要修改：[具体问题]
// 下一步：[你希望我做什么]
// ```

// ## 立即可用的提示词示例

// ### 原型设计提示词
// ```
// 请设计一个[功能]的HTML/CSS原型，包含以下元素：
// 1. [元素1]
// 2. [元素2]
// 3. [元素3]
// 风格要求：[简洁现代/企业风格等]
// 请先给出原型图描述，再提供HTML/CSS代码。
// ```

// ### 代码实现提示词
// ```
// 基于上面的原型，请实现以下功能：
// 1. 当用户[动作]时，应该[结果]
// 2. 数据应该从[来源]获取并显示在[位置]
// 3. 错误处理：当[错误情况]发生时，显示[处理方式]
// ```

// ## 实际操作示例

// 假设开发一个待办事项功能：

// 1. **功能定义**：
//    "请设计一个简单的待办事项功能，用户可以添加、标记完成和删除任务"

// 2. **获取原型**：
//    "请提供这个待办功能的HTML/CSS原型，包含任务输入框、任务列表和完成/删除按钮"

// 3. **代码实现**：
//    "基于上面的原型，请实现添加任务和标记完成的功能，使用JavaScript"

// 4. **功能扩展**：
//    "请添加本地存储功能，让任务在页面刷新后仍然保留"

// 这种简单直接的方式避免了复杂框架，让我们能立即开始合作并逐步优化流程。你觉得这样是否更容易落地实施？
// 尝试以下练习来巩固你的理解：
// 1. 创建一个 HashMap，存储你最喜欢的电影及其评分。
// 2. 遍历 HashMap，打印每部电影及其评分。
// 3. 修改某部电影的评分。
// 4. 删除一部电影的记录。
// 5. 检查某部电影是否在 HashMap 中。

let movies1: Map<string, number> = new Map();

movies1.set("Inception", 9);
movies1.set("The Dark Knight", 9);
movies1.set("Interstellar", 8);
movies1.set("The Matrix", 8);

// 遍历 HashMap | Iterate through HashMap
for (let [movie, score] of movies1.entries()) { // entries is a method that returns an iterator of [key, value] pairs
    console.log(`${movie}: ${score}`); // 修正：使用反引号
}

movies1.set("The Dark Knight", 5); // 修改评分

movies1.delete("Inception"); // 删除电影记录

console.log(movies1.has("The Dark Knight")); // 检查电影是否存在 struct